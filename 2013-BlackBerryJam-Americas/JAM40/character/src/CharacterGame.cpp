#include "CharacterGame.h"#include <camera/camera_api.h>#include <pthread.h>#include <sys/neutrino.h>// Declare our game instanceCharacterGame game;#define DELTA(x,y) ((x>y)?(x-y):(y-x))static pthread_mutex_t bufMutex = PTHREAD_MUTEX_INITIALIZER;static pthread_cond_t bufCond = PTHREAD_COND_INITIALIZER;static camera_buffer_t *bufQueue = NULL;static camera_buffer_t *cameraBuf = NULL;static camera_handle_t handle = CAMERA_HANDLE_INVALID;static pthread_t vf_tid;static int vf_chid;static int vf_coid;static struct sigevent vf_sigev;#define VF_PULSE_CODE  (123)static bool vf_stop = true;static bool camera_reuse = false;// Camera dimensions (RGB)// We'll find the actual dimensions once the camera is running.static int camW = 0;static int camWS = 0;static int camS = 0;static int camH = 0;// Node for camera viewerNode* camViewNode = NULL;Texture::Sampler* camViewSampler;// Input flags#define NORTH 1#define SOUTH 2#define EAST 4#define WEST 8#define RUNNING 16// Character defines#define WALK_SPEED  5.0f#define STRAFE_SPEED 1.5f#define RUN_SPEED 15.0f#define CAMERA_FOCUS_DISTANCE 16.0f#define BUTTON_1 0#define BUTTON_2 1int updateCameraData(){    // regenerate texture    pthread_mutex_lock(&bufMutex);    if (!bufQueue && !cameraBuf) {        uint64_t w1,w2;        ClockTime(CLOCK_MONOTONIC, NULL, &w1);        pthread_cond_wait(&bufCond, &bufMutex);        ClockTime(CLOCK_MONOTONIC, NULL, &w2);#ifdef DEBUG_INFO_PRINTOUT        fprintf(stderr, "waited %lld uS\n", (w2-w1)/1000);#endif        if (!bufQueue && !cameraBuf) {#ifdef DEBUG_INFO_PRINTOUT            fprintf(stderr, "no buffers\n");#endif            pthread_mutex_unlock(&bufMutex);            return -1;        }    }    camera_reuse = false;    if (bufQueue) {        if (cameraBuf) {            camera_return_buffer(handle, cameraBuf);            free(cameraBuf);        }        cameraBuf = bufQueue;        bufQueue = NULL;    } else {        // no new frame has arrive.. re-use last#ifdef DEBUG_INFO_PRINTOUT        fprintf(stderr, "reuse\n");#endif        camera_reuse = true;    }    pthread_mutex_unlock(&bufMutex);    return 0;}// From browser.texture sampleNode* addQuadModelAndNode(Scene* scene, Mesh* mesh){    Model* model = Model::create(mesh);    Node* node = scene->addNode();    node->setModel(model);    SAFE_RELEASE(model);    return node;}// From browser.texture sampleMaterial* setTextureUnlitMaterial(Model* model, bool mipmap = true){    Material* material = model->setMaterial("res/shaders/textured-unlit.vert", "res/shaders/textured-unlit.frag");    material->setParameterAutoBinding("u_worldViewProjectionMatrix", "WORLD_VIEW_PROJECTION_MATRIX");    // Allocate a texture.  Don't need to give it picture data yet, since it's not being rendered until later.    // NOTE: BGRA is the native pixel format of the RGB data coming from the camera (when endianness is considered),    // but GamePlay3d does not define such a constant.  Luckily, since all Texture::Format members are defined    // equivalently to their GL_ counterparts, this little hack to force it to create the texture in BGRA format works:    Texture* texture = Texture::create((Texture::Format)GL_BGRA, camWS, camH, NULL);    if (mipmap)        texture->generateMipmaps();    Texture::Sampler* sampler = Texture::Sampler::create(texture);    camViewSampler = sampler;    SAFE_RELEASE(texture);    material->getParameter("u_diffuseTexture")->setValue(sampler);    if (mipmap)        sampler->setFilterMode(Texture::LINEAR_MIPMAP_LINEAR, Texture::LINEAR);    else        sampler->setFilterMode(Texture::LINEAR, Texture::LINEAR);    sampler->setWrapMode(Texture::CLAMP, Texture::CLAMP);    material->getStateBlock()->setCullFace(true);    material->getStateBlock()->setDepthTest(true);    material->getStateBlock()->setDepthWrite(true);    return material;}void initializeCameraView(Scene* scene){    // Configure the camera view.    const float S = 0.75f; // scale of screen (use to adjust size)    const float W = 16.0f; // width of screen (use to adjust aspect ratio)    const float H = 9.0f;  // height of screen (use to adjust aspect ratio)    const float CH = 5.0f; // height of center of screen (use to move screen vertically)    const float R = 25.0f; // radius of room    const float D = 0.1f;  // distance screen sticks out from wall    // create a rectangular mesh which has u,v vectors set appropriately to deal with the strided texture    // (eg. the width of the camera buffer may be larger than the actual picture data)    Mesh* mesh = Mesh::createQuad(S*W/2, S*H/2, -S*W, -S*H, 0, 0, (float)camW / (float)camWS, 1);    Node* node = addQuadModelAndNode(scene, mesh);    SAFE_RELEASE(mesh);    // create our placeholder texture and load it up    setTextureUnlitMaterial(node->getModel(), false);    node->setTranslation(-(R-D), CH, 0);    node->setRotation(Vector3(0, 1, 0), M_PI_2);        camViewNode = node;}void updateCameraView(){    // only re-texture if the camera frame has changed since the last render pass    if (!camera_reuse) {        // simply do a texture upload!        camViewSampler->bind();        glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, camWS, camH, GL_BGRA, GL_UNSIGNED_BYTE, cameraBuf->framebuf);    }}static void* vf_thread(void* arg){    int rcvid;    struct _pulse pulse;    camera_eventkey_t key;    camera_buffer_t inbuf;    // hook in to the viewfinder buffer stream in read-only mode.    // when a frame becomes available, the event will be delivered to us.    // NOTE: we should really be checking the CAMERA_FEATURE_PREVIEWISVIDEO feature    // to make sure we are connecting to the correct image stream, but since all    // devices that we currently build use the same frames for the viewfinder and    // for video recording, I am not bothering to do so for the sake of clarity.    // If the feature is reported as not available, then we would call camera_enable_video_event()    // instead.    if (camera_enable_viewfinder_event(handle,                                       CAMERA_EVENTMODE_READONLY,                                       &key,                                       &vf_sigev) != CAMERA_EOK) {        fprintf(stderr, "failed to attach viewfinder read/write event\n");        return NULL;    }    // NOTE: this is NEW!    // if we are likely to be handling any camera buffer data, we must be sure    // to inform the camera service that we are using resources.    camera_register_resource(handle);    // now that we have registered our intent to use resources, we will be notified    // if the camera service is going to be unmapping our buffers if they are needed    // by a higher priority system process.  if we do not register in this way,    // the buffers can be unmapped AT ANY TIME, causing us to crash if we try to    // reference the buffer data.  We must be sure to de-register the resource when    // we are finished.  If the CAMERA_STATUS_RESOURCENOTAVAIL notification is    // received at any time, we must be sure to immediately release all buffers and    // call camera_deregister_resource().  There is a time limit on doing this, so do it fast!    while(!vf_stop) {        camera_buffer_t *release = NULL;        rcvid = MsgReceivePulse(vf_chid, &pulse, sizeof pulse, NULL);        if (rcvid != 0) continue;   // not a pulse        if (pulse.code != VF_PULSE_CODE) continue;  // not a pulse we can handle        if (vf_stop) break;     // stop if we're being told to stop        // okay, at this point, we can be sure the pulse code is meant to indicate that        // a new frame is available from the camera to process.        // retrieve the input buffer for processing        camera_get_viewfinder_buffers(handle,                                      key,                                      &inbuf,                                      NULL);        pthread_mutex_lock(&bufMutex);        // stale frame in queue.. overwrite        if (bufQueue) {            release = bufQueue;        }        bufQueue = (camera_buffer_t*)calloc(1, inbuf.framesize);        memcpy(bufQueue, &inbuf, inbuf.framesize);        fprintf(stderr,"frame %d(%d) x %d\n",                inbuf.framedesc.rgb8888.width,                inbuf.framedesc.rgb8888.stride,                inbuf.framedesc.rgb8888.height);        pthread_cond_signal(&bufCond);        pthread_mutex_unlock(&bufMutex);        if (release) {#ifdef DEBUG_INFO_PRINTOUT            fprintf(stderr,"releasing %p\n", release->framebuf);#endif            camera_return_buffer(handle,                                 release);            free(release);        }    }    // de-register the viewfinder read/write event    camera_disable_event(handle, key);    // de-register our use of resources.  if the thread were being shut down due to the    // CAMERA_STATUS_RESOURCENOTAVAIL status being received, this call will also signal    // the camera service that it may proceed with revoking resources.    camera_deregister_resource(handle);    return NULL;}int initCamera(){    //Open camera    if (camera_open(CAMERA_UNIT_FRONT, CAMERA_MODE_RW, &handle)) return -1;    unsigned int orientation = 0;    camera_get_native_orientation(handle, &orientation);    // going to run a query here to find a 480P 16:9 resolution    // (error checking is omitted for clarity)    unsigned int num;    camera_get_video_vf_resolutions(handle, 0, &num, NULL);    camera_res_t res[num];    camera_get_video_vf_resolutions(handle, num, &num, res);    unsigned int best = 0;    unsigned int i;    for (i=0; i<num; i++) {        fprintf(stderr, "Supported resolution: %d x %d\n", res[i].width, res[i].height);        if ((orientation % 180) == 0) {            if ((DELTA(res[i].height, 480) <= DELTA(res[best].height, 480)) &&                (DELTA(res[i].width, 480*16/9) <= DELTA(res[best].width, 480*16/9))) {                best = i;            }        } else {            if ((DELTA(res[i].width, 480) <= DELTA(res[best].width, 480)) &&                (DELTA(res[i].height, 480*16/9) <= DELTA(res[best].height, 480*16/9))) {                best = i;            }        }    }    fprintf(stderr, "Selecting resolution %d x %d\n", res[best].width, res[best].height);    // get camera running    if (camera_set_videovf_property(handle,                                    CAMERA_IMGPROP_CREATEWINDOW, 0,                                    CAMERA_IMGPROP_FORMAT, CAMERA_FRAMETYPE_RGB8888,                                    CAMERA_IMGPROP_FRAMERATE, 30.0,                                    // note: using the rotation value corresponding to the native orientation                                    // gives the best performance since the output from the sensor will not be                                    // passed through a rotation stage on devices that require such a step.                                    CAMERA_IMGPROP_ROTATION, (360-orientation) % 360,                                    CAMERA_IMGPROP_WIDTH, res[best].width,                                    CAMERA_IMGPROP_HEIGHT, res[best].height)) return -1;    if (camera_start_video_viewfinder(handle, NULL, NULL, NULL)) return -1;    // now we're going to do something new.  we're going to spawn a thread which will    // implement our face-blurring filter.    // first though, let's set up the channel/connection/sigevent stuff we're going to    // be using to communicate with the camera and with the main thread (to tell it to stop)    vf_chid = ChannelCreate(0);    vf_coid = ConnectAttach(0, 0, vf_chid, _NTO_SIDE_CHANNEL, 0);    SIGEV_PULSE_INIT(&vf_sigev,                     vf_coid,                     SIGEV_PULSE_PRIO_INHERIT,                     VF_PULSE_CODE,                     0);    vf_stop = false;    pthread_create(&vf_tid, NULL, vf_thread, NULL);    // wait for the first frame to be received so that we know the physical buffer details    pthread_mutex_lock(&bufMutex);    if (!bufQueue) {        pthread_cond_wait(&bufCond, &bufMutex);    }    // cache frame dimensions and stride (in both bytes & pixels)    camW = bufQueue->framedesc.rgb8888.width;    camH = bufQueue->framedesc.rgb8888.height;    camS = bufQueue->framedesc.rgb8888.stride;    camWS = camS / 4;    pthread_mutex_unlock(&bufMutex);    return 0;}CharacterGame::CharacterGame()    : _font(NULL), _scene(NULL), _character(NULL), _characterNode(NULL), _characterMeshNode(NULL), _characterShadowNode(NULL), _basketballNode(NULL),      _animation(NULL), _currentClip(NULL), _jumpClip(NULL), _kickClip(NULL), _rotateX(0), _materialParameterAlpha(NULL),      _keyFlags(0), _drawDebug(0), _wireframe(false), _hasBall(false), _applyKick(false), _gamepad(NULL){    _buttonPressed = new bool[2];}void CharacterGame::initialize(){    // Enable multi-touch (only affects devices that support multi-touch).    setMultiTouch(true);    // Display the gameplay splash screen for at least 1 second.    displayScreen(this, &CharacterGame::drawSplash, NULL, 1000L);    // Load the font.    _font = Font::create("res/common/arial40.gpb");    // Load scene.    _scene = Scene::load("res/common/scene.scene");    // Update the aspect ratio for our scene's camera to match the current device resolution.    _scene->getActiveCamera()->setAspectRatio(getAspectRatio());        // Initialize the physics character.    initializeCharacter();    // Create a collision object for the ceiling.    Node* ceiling = _scene->addNode("ceiling");    ceiling->setTranslationY(14.5f);    PhysicsRigidBody::Parameters rbParams;    rbParams.mass = 0.0f;    rbParams.friction = 0.5f;    rbParams.restitution = 0.75f;    rbParams.linearDamping = 0.025f;    rbParams.angularDamping = 0.16f;    ceiling->setCollisionObject(PhysicsCollisionObject::RIGID_BODY, PhysicsCollisionShape::box(Vector3(49.5f, 1.0f, 49.5f)), &rbParams);    // Initialize scene.    _scene->visit(this, &CharacterGame::initializeScene);        if (initCamera() == -1) {        fprintf(stderr, "INIT CAMERA FAILED\n");    }        // Create a camera viewer.    initializeCameraView(_scene);        _gamepad = getGamepad(0);}bool CharacterGame::initializeScene(Node* node){    Model* model = node->getModel();    if (model && model->getMaterial())    {        initializeMaterial(_scene, node, model->getMaterial());    }    return true;}void CharacterGame::initializeMaterial(Scene* scene, Node* node, Material* material){    // Bind light shader parameters to dynamic objects only    if (node->hasTag("dynamic"))    {        Node* lightNode = scene->findNode("sun");        material->getParameter("u_ambientColor")->bindValue(scene, &Scene::getAmbientColor);        material->getParameter("u_lightColor")->bindValue(lightNode->getLight(), &Light::getColor);        material->getParameter("u_lightDirection")->bindValue(lightNode, &Node::getForwardVectorView);    }}void CharacterGame::initializeCharacter(){    Node* node = _scene->findNode("boycharacter");        // Store the physics character object.    _character = static_cast<PhysicsCharacter*>(node->getCollisionObject());        // Store character nodes.    _characterNode = node->findNode("boyScale");    _characterMeshNode = _scene->findNode("boymesh");    _characterShadowNode = _scene->findNode("boyshadow");    // Get the basketball node.    _basketballNode = _scene->findNode("basketball");    _basketballNode->getCollisionObject()->addCollisionListener(this);    _floorLevel = _basketballNode->getTranslationY();    // Store the alpha material parameter from the character's model.    _materialParameterAlpha = _characterMeshNode->getModel()->getMaterial()->getTechniqueByIndex(0)->getPassByIndex(0)->getParameter("u_modulateAlpha");    // Load character animations.    _animation = node->getAnimation("animations");    _animation->createClips("res/common/boy.animation");    _jumpClip = _animation->getClip("jump");    _jumpClip->addListener(this, _jumpClip->getDuration() - 250);    _kickClip = _animation->getClip("kick");    _kickClip->addListener(this, _kickClip->getDuration() - 250); // when to cross fade    _kickClip->addListener(this, 416);  // when to turn on _isKicking.    // Start playing the idle animation when we load.    play("idle", true);}void CharacterGame::finalize(){    SAFE_RELEASE(_scene);    SAFE_RELEASE(_font);    SAFE_DELETE_ARRAY(_buttonPressed);    // stop camera    if (!vf_stop) {        vf_stop = true;        MsgSendPulse(vf_coid, -1, VF_PULSE_CODE, 0);        pthread_join(vf_tid, NULL);    }    if (handle != CAMERA_HANDLE_INVALID) {        camera_stop_video_viewfinder(handle);        camera_close(handle);        handle = CAMERA_HANDLE_INVALID;    }}void CharacterGame::drawSplash(void* param){    clear(CLEAR_COLOR_DEPTH, Vector4(0, 0, 0, 1), 1.0f, 0);    SpriteBatch* batch = SpriteBatch::create("res/logo_powered_white.png");    batch->start();    batch->draw(getWidth() * 0.5f, getHeight() * 0.5f, 0.0f, 512.0f, 512.0f, 0.0f, 1.0f, 1.0f, 0.0f, Vector4::one(), true);    batch->finish();    SAFE_DELETE(batch);}bool CharacterGame::drawScene(Node* node, bool transparent){    if (node->getModel() && (transparent == node->hasTag("transparent")))        node->getModel()->draw(_wireframe);    return true;}void CharacterGame::play(const char* id, bool repeat, float speed){    AnimationClip* clip = _animation->getClip(id);    // Set clip properties    clip->setSpeed(speed);    clip->setRepeatCount(repeat ? AnimationClip::REPEAT_INDEFINITE : 1);    // Is the clip already playing?    if (clip == _currentClip && clip->isPlaying())        return;    if (_jumpClip->isPlaying() || _kickClip->isPlaying())    {        _currentClip = clip;        return;    }    // If a current clip is playing, crossfade into the new one    if (_currentClip && _currentClip->isPlaying())    {        _currentClip->crossFade(clip, 150);    }    else    {        clip->play();    }    _currentClip = clip;}void CharacterGame::jump(){    if (isOnFloor() && !_kickClip->isPlaying())    {        play("jump", false, 0.55f);        _character->jump(3.0f);    }}void CharacterGame::kick(){    if (!_jumpClip->isPlaying())        play("kick", false, 1.75f);    _kicking = true;}bool CharacterGame::isOnFloor() const{    return (std::fabs(_character->getCurrentVelocity().y) < MATH_EPSILON);}void CharacterGame::update(float elapsedTime){    // Update the camera.    updateCameraData();    updateCameraView();    if (_applyKick)    {        // apply impulse from kick.        Vector3 impulse(-_characterNode->getForwardVectorWorld());        impulse.normalize();        impulse.y = 1.0f; // add some lift to kick        impulse.scale(16.6f); //scale the impulse.        ((PhysicsRigidBody*)_basketballNode->getCollisionObject())->applyImpulse(impulse);        _hasBall = false;        _applyKick = false;    }    if (!_kickClip->isPlaying())        _kicking = false;    if (_gamepad->isButtonDown(Gamepad::BUTTON_A))    {        if (_buttonPressed[BUTTON_1])        {            _buttonPressed[BUTTON_1] = false;            // Jump while the gamepad button is being pressed            jump();        }    }    else    {        _buttonPressed[BUTTON_1] = true;    }    if (_gamepad->isButtonDown(Gamepad::BUTTON_B))    {        if (_buttonPressed[BUTTON_2])        {            _buttonPressed[BUTTON_2] = false;            kick();        }    }    else    {        _buttonPressed[BUTTON_2] = true;    }    _currentDirection.set(Vector2::zero());    if (!_kicking)    {        if (_gamepad->getJoystickCount() > 0)        {            _gamepad->getJoystickValues(0, &_currentDirection);        }    }    if (_gamepad->getJoystickCount() > 1)    {        Vector2 out;        _gamepad->getJoystickValues(1, &out);       _character->getNode()->rotateY(-MATH_DEG_TO_RAD(out.x * 2.0f));    }        if (_currentDirection.isZero())    {        // Construct direction vector from keyboard input        if (_keyFlags & NORTH)            _currentDirection.y = 1;        else if (_keyFlags & SOUTH)            _currentDirection.y = -1;        else            _currentDirection.y = 0;        if (_keyFlags & EAST)            _currentDirection.x = 1;        else if (_keyFlags & WEST)            _currentDirection.x = -1;        else             _currentDirection.x = 0;        _currentDirection.normalize();        if ((_keyFlags & RUNNING) == 0)            _currentDirection *= 0.5f;    }    // Update character animation and velocity    if (_currentDirection.isZero())    {        play("idle", true);        _character->setVelocity(Vector3::zero());    }    else    {        bool running = (_currentDirection.lengthSquared() > 0.75f);        float speed = running ? RUN_SPEED : WALK_SPEED;        play(running ? "running" : "walking", true, 1.0f);        // Orient the character relative to the camera so he faces the direction we want to move.        const Matrix& cameraMatrix = _scene->getActiveCamera()->getNode()->getWorldMatrix();        Vector3 cameraRight, cameraForward;        cameraMatrix.getRightVector(&cameraRight);        cameraMatrix.getForwardVector(&cameraForward);        // Get the current forward vector for the mesh node (negate it since the character was modelled facing +z)        Vector3 currentHeading(-_characterNode->getForwardVectorWorld());        // Construct a new forward vector for the mesh node        Vector3 newHeading(cameraForward * _currentDirection.y + cameraRight * _currentDirection.x);        // Compute the rotation amount based on the difference between the current and new vectors        float angle = atan2f(newHeading.x, newHeading.z) - atan2f(currentHeading.x, currentHeading.z);        if (angle > MATH_PI)            angle -= MATH_PIX2;        else if (angle < -MATH_PI)            angle += MATH_PIX2;        angle *= (float)elapsedTime * 0.001f * MATH_PIX2;        _characterNode->rotate(Vector3::unitY(), angle);        // Update the character's velocity        Vector3 velocity = -_characterNode->getForwardVectorWorld();        velocity.normalize();        velocity *= speed;        _character->setVelocity(velocity);    }    // Adjust camera to avoid it from being obstructed by walls and objects in the scene.    adjustCamera(elapsedTime);    // Project the character's shadow node onto the surface directly below him.    PhysicsController::HitResult hitResult;    Vector3 v = _character->getNode()->getTranslationWorld();    if (getPhysicsController()->rayTest(Ray(Vector3(v.x, v.y + 1.0f, v.z), Vector3(0, -1, 0)), 100.0f, &hitResult, NULL))        _characterShadowNode->setTranslation(Vector3(hitResult.point.x, hitResult.point.y + 0.1f, hitResult.point.z));    if (_hasBall)    {        // This is the first time entering this block of code if the basketball is still enabled.        // Disable physics on basketball, and create a bigger collision object around the boy to include the ball.        // This will ensure the boy cannot walk through walls/objects with the basketball.        PhysicsRigidBody* basketball = (PhysicsRigidBody*)_basketballNode->getCollisionObject();        if (basketball->isEnabled())            grabBall();        // Capture the basketball's old position, and then calculate the basketball's new position in front of the character        _oldBallPosition = _basketballNode->getTranslationWorld();        Vector3 characterForwardVector(_characterNode->getForwardVectorWorld());        Vector3 translation(_characterNode->getTranslationWorld() + characterForwardVector.normalize() * -2.2f);        translation.y = _floorLevel;        // Calculates rotation to be applied to the basketball.        Vector3 rotationVector(0.0f, -_basketballNode->getBoundingSphere().radius, 0.0f);        Vector3::cross(rotationVector, _oldBallPosition - translation, &rotationVector);        if (!rotationVector.isZero())        {            Matrix m;            _basketballNode->getWorldMatrix().transpose(&m);            Vector3 rotNorm;            m.transformVector(rotationVector, &rotNorm);            rotNorm.normalize();            _basketballNode->rotate(rotNorm, rotationVector.length());        }                _basketballNode->setTranslation(translation.x, _floorLevel, translation.z);    }}void CharacterGame::render(float elapsedTime){    // Clear the color and depth buffers.    clear(CLEAR_COLOR_DEPTH, Vector4(0.41f, 0.48f, 0.54f, 1.0f), 1.0f, 0);    // Draw our scene, with separate passes for opaque and transparent objects.    _scene->visit(this, &CharacterGame::drawScene, false);    _scene->visit(this, &CharacterGame::drawScene, true);    // Draw debug info (physics bodies, bounds, etc).    switch (_drawDebug)    {    case 1:        getPhysicsController()->drawDebug(_scene->getActiveCamera()->getViewProjectionMatrix());        break;    case 2:        _scene->drawDebug(Scene::DEBUG_BOXES);        break;    case 3:        _scene->drawDebug(Scene::DEBUG_SPHERES);        break;    }    _gamepad->draw();    // Draw FPS    _font->start();    char fps[32];    sprintf(fps, "%d", getFrameRate());    _font->drawText(fps, 5, 5, Vector4(1,1,0,1), 20);    _font->finish();}void CharacterGame::keyEvent(Keyboard::KeyEvent evt, int key){    if (evt == Keyboard::KEY_PRESS)    {        switch (key)        {        case Keyboard::KEY_ESCAPE:            exit();            break;        case Keyboard::KEY_W:        case Keyboard::KEY_CAPITAL_W:            _keyFlags |= NORTH;            _keyFlags &= ~SOUTH;            break;        case Keyboard::KEY_S:        case Keyboard::KEY_CAPITAL_S:            _keyFlags |= SOUTH;            _keyFlags &= ~NORTH;            break;        case Keyboard::KEY_A:        case Keyboard::KEY_CAPITAL_A:            _keyFlags |= WEST;            _keyFlags &= ~EAST;            break;        case Keyboard::KEY_D:        case Keyboard::KEY_CAPITAL_D:            _keyFlags |= EAST;            _keyFlags &= ~WEST;            break;        case Keyboard::KEY_B:            _drawDebug++;            if (_drawDebug > 3)                _drawDebug = 0;            break;        case Keyboard::KEY_SPACE:            jump();            break;        case Keyboard::KEY_SHIFT:            _keyFlags |= RUNNING;            break;        case Keyboard::KEY_M:        case Keyboard::KEY_CAPITAL_M:            _wireframe = !_wireframe;            break;        case Keyboard::KEY_C:        case Keyboard::KEY_CAPITAL_C:            clone();            break;        }    }    else if (evt == Keyboard::KEY_RELEASE)    {        switch (key)        {        case Keyboard::KEY_W:        case Keyboard::KEY_CAPITAL_W:            _keyFlags &= ~NORTH;            break;        case Keyboard::KEY_S:        case Keyboard::KEY_CAPITAL_S:            _keyFlags &= ~SOUTH;            break;        case Keyboard::KEY_A:        case Keyboard::KEY_CAPITAL_A:            _keyFlags &= ~WEST;            break;        case Keyboard::KEY_D:        case Keyboard::KEY_CAPITAL_D:            _keyFlags &= ~EAST;            break;        case Keyboard::KEY_SHIFT:            _keyFlags &= ~RUNNING;            break;        }    }}void CharacterGame::touchEvent(Touch::TouchEvent evt, int x, int y, unsigned int contactIndex){    // This should only be called if the gamepad did not handle the touch event.    switch (evt)    {    case Touch::TOUCH_PRESS:        {            _rotateX = x;        }        break;    case Touch::TOUCH_RELEASE:        {            _rotateX = 0;        }        break;    case Touch::TOUCH_MOVE:        {            int deltaX = x - _rotateX;            _rotateX = x;            _character->getNode()->rotateY(-MATH_DEG_TO_RAD(deltaX * 0.5f));        }        break;    default:        break;    }}bool CharacterGame::mouseEvent(Mouse::MouseEvent evt, int x, int y, int wheelDelta){    if (evt == Mouse::MOUSE_PRESS_RIGHT_BUTTON)    {        kick();        return true;    }    return false;}void CharacterGame::gamepadEvent(Gamepad::GamepadEvent evt, Gamepad* gamepad){    switch(evt)    {    case Gamepad::CONNECTED_EVENT:    case Gamepad::DISCONNECTED_EVENT:        _gamepad = getGamepad(0);        break;    }}void CharacterGame::adjustCamera(float elapsedTime){    static float cameraOffset = 0.0f;    PhysicsController* physics = getPhysicsController();    Node* cameraNode = _scene->getActiveCamera()->getNode();    // Reset camera    if (cameraOffset != 0.0f)    {        cameraNode->translateForward(-cameraOffset);        cameraOffset = 0.0f;    }    Vector3 cameraPosition = cameraNode->getTranslationWorld();    Vector3 cameraDirection = cameraNode->getForwardVectorWorld();    cameraDirection.normalize();    // Get focal point of camera (use the resolved world location of the head joint as a focal point)    Vector3 focalPoint(cameraPosition + (cameraDirection * CAMERA_FOCUS_DISTANCE));    Vector3 oldPosition = cameraNode->getTranslationWorld();    PhysicsController::HitResult result;    PhysicsCollisionObject* occlusion = NULL;    do    {        // Perform a ray test to check for camera collisions        if (!physics->sweepTest(cameraNode->getCollisionObject(), focalPoint, &result) || result.object == _character)            break;        occlusion = result.object;        // Step the camera closer to the focal point to resolve the occlusion        float d = cameraNode->getTranslationWorld().distance(result.point);        cameraNode->translateForward(d);        cameraOffset += d;        while (physics->sweepTest(cameraNode->getCollisionObject(), focalPoint, &result) && result.object == occlusion)        {            // Prevent the camera from getting too close to the character.            // Without this check, it's possible for the camera to fly past the character            // and essentially end up in an infinite loop here.            if (cameraNode->getTranslationWorld().distanceSquared(focalPoint) <= 2.0f)                return;            cameraNode->translateForward(0.1f);            cameraOffset += 0.1f;        }    } while (true);    // If the character is closer than 10 world units to the camera, apply transparency to the character so he does not obstruct the view.    if (occlusion)    {        float d = _scene->getActiveCamera()->getNode()->getTranslationWorld().distance(_characterNode->getTranslationWorld());        float alpha = d < 10 ? (d * 0.1f) : 1.0f;        _characterMeshNode->setTag("transparent", alpha < 1.0f ? "true" : NULL);        _materialParameterAlpha->setValue(alpha);    }    else    {        _characterMeshNode->setTag("transparent", NULL);        _materialParameterAlpha->setValue(1.0f);    }}void CharacterGame::animationEvent(AnimationClip* clip, AnimationClip::Listener::EventType type){    if (clip == _kickClip && !_applyKick)    {        if (_hasBall)        {            _applyKick = true;            releaseBall();        }    }    else    {        clip->crossFade(_currentClip, 150);    }}void CharacterGame::clone(){    Node* clone = _scene->findNode("boycharacter")->clone();    Animation* cloneAnimation = clone->getAnimation();    // Find the current clip and have the clone play that clip repeatedly.    const char* clipId = _currentClip->getId();    if (_jumpClip->isPlaying())        clipId = _jumpClip->getId();    AnimationClip* clip = cloneAnimation->getClip(clipId);    clip->setRepeatCount(AnimationClip::REPEAT_INDEFINITE);    clip->play();    _scene->addNode(clone);    clone->release();}void CharacterGame::collisionEvent(PhysicsCollisionObject::CollisionListener::EventType type,                                    const PhysicsCollisionObject::CollisionPair& collisionPair,                                    const Vector3& contactPointA,                                    const Vector3& contactPointB){    // objectA -> basketball, only care about collisions between the physics character and the basketball.    if (type == PhysicsCollisionObject::CollisionListener::COLLIDING && collisionPair.objectB == _character)        _hasBall = true;}void CharacterGame::grabBall(){    // Disables physics on the basketball, and increases the size of the character's collison object to include the basketball.    _basketballNode->getCollisionObject()->setEnabled(false);    PhysicsRigidBody::Parameters rbParams;    rbParams.mass = 20.0f;    Vector3 currentVelocity = _character->getCurrentVelocity();    Node* boy = _character->getNode();    boy->setCollisionObject(PhysicsCollisionObject::CHARACTER, PhysicsCollisionShape::capsule(2.9f, 6.0f, Vector3(0.0f, 3.0f, 0.0f), true), &rbParams);    _character = static_cast<PhysicsCharacter*>(boy->getCollisionObject());    _character->setMaxSlopeAngle(0.0f);    _character->setMaxStepHeight(0.0f);    _character->setVelocity(currentVelocity);}void CharacterGame::releaseBall(){    // Decreases the size of the character's collision object and re-enables physics simulation on the basketball.    PhysicsRigidBody::Parameters rbParams;    rbParams.mass = 20.0f;    Vector3 velocity = _character->getCurrentVelocity();    Node* boy = _character->getNode();    boy->setCollisionObject(PhysicsCollisionObject::CHARACTER, PhysicsCollisionShape::capsule(1.2f, 6.0f, Vector3(0.0f, 3.0f, 0.0f), true), &rbParams);    _character = static_cast<PhysicsCharacter*>(boy->getCollisionObject());    _character->setVelocity(velocity);    _character->setMaxSlopeAngle(0.0f);    _character->setMaxStepHeight(0.0f);        PhysicsRigidBody* basketball = (PhysicsRigidBody*) _basketballNode->getCollisionObject();    basketball->setEnabled(true);}